= Why Event Sourcing Is Hard?

Mateusz Kubuszok

== About me

[%step]
* breaking things in Scala for 7+ years
* breaking things for money for 10 years
* breaking things for fun for 18(?) years
* a little bit of open source
* blog at https://kubuszok.com[Kubuszok.com]
* niche https://leanpub.com/jvm-scala-book[Things you need to know about JVM (that matter in Scala)] ebook

[NOTE.speaker]
--
Every presentation should staart with some excuse, why you even are here
--

== Agenda

[%step]
* What is Event Sourcing?
* Pitfalls with processing events
* Pitfalls with creating events
* Pitfalls with events lifecycle
* Summary

[NOTE.speaker]
--
Disclaimer: people who worked with event sourcing most likely experiences all if these so they can take everything in this presentation as granted.
--

== What is Event Sourcing?

[NOTE.speaker]
--
Instead of starting with a dry definition, let's go on a small journey.
--

=== !

[source, scala]
--
case class User(id: String, name: String)
--

[source, scala]
--
// called directly by UI
def changeUsername(userID:  String, newName: String): Unit =
  val user = getUser(userID)
  val updatedUser = user.copy(name = newName)
  saveUser(user)
--

[source, scala]
--
// fetch from DB
def getUser(userID: String): User

// saves to DB
def saveUser(user: User): Unit
--

[NOTE.speaker]
--
Sorry for not purely functional code, but I didn't want to spend first half pf presentation explaining monads.

Here we have a code which couples action, which how and when it is executed. Let's decouple things a bit.
--

=== !

[source, scala]
--
trait UserActionListener:
  def changeUsername(userID: String, newName: String)
--

[source, scala]
--
// added to UI
val userActionListeners: List[UserActionListener]

// still in UI
def changeUsername(userID: String, newName: String): Unit =
  userActionListeners.foreach { listener =>
    listener.changeUsername(userID, newName)
  }
--

[NOTE.speaker]
--
Here we have a solution popular in many GUI frameworks.

We decoupled the UI from the action that it performs.

But every component still needs its own collection of listeners.

And everything is still blocking and synchronous.
--

=== !

[source, scala]
--
enum UserAction:
  case ChangeUsername(userID: String, newName: String)

trait UserActionEventBus:
  def publish(action: UserAction): Unit
  def subscribe(f: UserAction => Unit): Unit
--

[source, scala]
--
// in UI
def changeUsername(userID: String, newName: String): Unit =
  bus.publish(UserAction.ChangeUserName(userID, newName))
--

[source, scala]
--
// elsewere
bus.subscribe {
  case UserAction.ChangeUsername(userID, newName) => ...
  case _ => ()
}
--

[NOTE.speaker]
--
Now, everyone can write to the event bus, and also anyone can listen.

That gives a lot of flexibity. But, why should we limit ourselved to just local application? At this point we can send the events over wire and respond to them anytime!

But this still defines what needs to happen, not what happened, it is not deterministic in case someone doesn't respond to command in time!
--

=== !

[source, scala]
--
enum UserEvent:
  def userID: String

  case UsernameChanged(userID: String, newName: String)
--

[source, scala]
--
// instead of List it might be Stream, Iterator or Producer
val userEvents: List[UserEvent]
--

[source, scala]
--
val ourUserID: String // specific User's ID

userEvents.foldLeft(User(id = ourUserID, name = "")) {
  case (user, UserEvent.UsernameChanged(userID, newName)) =>
    if (userID == ourUserID) => user.copy(name = newName)
    else user
} // User with all events applied
--

[NOTE.speaker]
--
Here, we decided to represent what happened, rather than what is requested to happen.

This allows us to deterministically compute state. It is decoupled with when it happened and where it happened.

We might change our about what to start with and how to use each event, and we can still compute the state because we rememver everything.

But this is the toy example because we got rid of side effects.
--

== Pitfalls with processing events

== Pitfalls with creating events

== Pitfalls with events lifecycle

== Summary

== Thank you!




== TODO

Hello World - Good Bye Cruel World

[NOTE.speaker]
--
Actually things aren't that bad
--

== Source code

[source, scala]
--
val test = task
  .map(identity)
  .flatMap(a => Something(b))
  .runSyncUnsafe
  // result
--
