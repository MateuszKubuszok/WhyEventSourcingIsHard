= Why Event Sourcing Is Hard?

Mateusz Kubuszok

== About me

[%step]
* breaking things in Scala for 7+ years
* breaking things for money for 10 years
* breaking things for fun for 18(?) years
* a little bit of open source
* blog at https://kubuszok.com[Kubuszok.com]
* niche https://leanpub.com/jvm-scala-book[Things you need to know about JVM (that matter in Scala)] ebook

[NOTE.speaker]
--
Every presentation should staart with some excuse, why you even are here
--

== Agenda

[%step]
* What is Event Sourcing?
* Pitfalls with processing events
* Pitfalls with creating events
* Pitfalls with events lifecycle
* Summary

[NOTE.speaker]
--
Disclaimer: people who worked with event sourcing most likely experiences all if these so they can take everything in this presentation as granted.
--

== What is Event Sourcing?

[NOTE.speaker]
--
Instead of starting with a dry definition, let's go on a small journey.
--

=== !

[source, scala]
--
case class User(id: String, name: String)
--

[source, scala]
--
// called directly by UI
def changeUsername(userID:  String, newName: String): Unit =
  val user = getUser(userID)
  val updatedUser = user.copy(name = newName)
  saveUser(user)
--

[source, scala]
--
// fetch from DB
def getUser(userID: String): User

// saves to DB
def saveUser(user: User): Unit
--

[NOTE.speaker]
--
Sorry for not purely functional code, but I didn't want to spend first half pf presentation explaining monads.

Here we have a code which couples action, which how and when it is executed. Let's decouple things a bit.
--

=== !

[source, scala]
--
trait UserActionListener:
  def changeUsername(userID: String, newName: String)
--

[source, scala]
--
// added to UI
val userActionListeners: List[UserActionListener]

// still in UI
def changeUsername(userID: String, newName: String): Unit =
  userActionListeners.foreach { listener =>
    listener.changeUsername(userID, newName)
  }
--

[NOTE.speaker]
--
Here we have a solution popular in many GUI frameworks.

We decoupled the UI from the action that it performs.

But every component still needs its own collection of listeners.

And everything is still blocking and synchronous.
--

=== !

[source, scala]
--
enum UserAction:
  case ChangeUsername(userID: String, newName: String)

trait UserActionEventBus:
  def publish(action: UserAction): Unit
  def subscribe(f: UserAction => Unit): Unit
--

[source, scala]
--
// in UI
def changeUsername(userID: String, newName: String): Unit =
  bus.publish(UserAction.ChangeUserName(userID, newName))
--

[source, scala]
--
// elsewere
bus.subscribe {
  case UserAction.ChangeUsername(userID, newName) => ...
  case _ => ()
}
--

[NOTE.speaker]
--
Now, everyone can write to the event bus, and also anyone can listen.

That gives a lot of flexibity. But, why should we limit ourselved to just local application? At this point we can send the events over wire and respond to them anytime!

But this still defines what needs to happen, not what happened, it is not deterministic in case someone doesn't respond to command in time!
--

[transition="slide-in fade-out"]
=== !

[source, scala]
--
enum UserEvent:
  def userID: String

  case UsernameChanged(userID: String, newName: String)
--

[source, scala]
--
// instead of List it might be Stream, Iterator or Producer
val userEvents: List[UserEvent]
--

[source, scala]
--
val ourUserID: String // specific User's ID

userEvents.foldLeft(User(id = ourUserID, name = "")) {
  (user, event) =>
    event match
      case UserEvent.UsernameChanged(userID, name) =>
        if (userID == ourUserID) user.copy(name = name)
        else user
} // returns User with all events applied
--

[NOTE.speaker]
--
Here, we decided to represent what happened, rather than what is requested to happen.

This allows us to deterministically compute state. It is decoupled with when it happened and where it happened.

We might change our about what to start with and how to use each event, and we can still compute the state because we rememver everything.

But this is the toy example because we got rid of side effects. It only appears in e.g. React or similar.

But remember this foldLeft intuition! In two steps it will stop looking like this while still preserving this intution.
--

[transition="fade-in slide-out"]
=== !

[source, scala]
--
enum UserEvent:
  def userID: String

  case UsernameChanged(userID: String, newName: String)
--

[source, scala]
--
// this has to be streamed from the outer world
val userEvents: List[UserEvent]
--

[source, scala]
--
val ourUserID: String // specific User's ID

userEvents.foldLeft(User(id = ourUserID, name = "")) {
  (user, event) =>
    event match
      case UserEvent.UsernameChanged(userID, name) =>
        if (userID == ourUserID) user.copy(name = name)
        else user // result should be stored somewhere
}
--

[transition="slide-in fade-out"]
=== !

[source, scala]
--
val ourUserID: String // specific User's ID
val currentState: Option[User] = fetchUser(ourUserID) // DB
--

[source, scala]
--
val lastOffset: String  // last processed event
def userEvents(offset: String): Stream[(UserEvent, Offset)]
--

[source, scala]
--
userEvents(lastOffset).foldLeft(
  currentState.getOrElse(User(id = ourUserID, name = ""))
) { (user, eventWithOffset) =>
  eventWithOffset match
    case (UserEvent.UsernameChanged(id, name), offset) =>
      val newUser =
        if (id == ourUserID) user.copy(name = name)
        else user
      saveUser(newUser) // updates DB
      saveOffset(offset) // updates DB
      newUser
}
--

[NOTE.speaker]
--
This still resembles the foldLeft code, to ease in how the code will usually look like.
--

[transition="fade-in slide-out"]
=== !

[source, scala]
--
val ourUserID: String // we should compute all entities!
val currentState: Option[User] = fetchUser(ourUserID) // DB
--

[source, scala]
--
val lastOffset: String  // offset absent before the 1st run!
def userEvents(offset: String): Stream[(UserEvent, Offset)]
--

[source, scala]
--
userEvents(lastOffset).foldLeft(
  currentState.getOrElse(User(id = ourUserID, name = ""))
) { (user, eventWithOffset) =>
  eventWithOffset match
    case (UserEvent.UsernameChanged(id, name), offset) =>
      val newUser =
        if (id == ourUserID) user.copy(name = name)
        else user
      saveUser(newUser) // updates DB
      saveOffset(offset) // updates DB
      newUser // we don't need to return a value here
} // and neither here
--

=== !

[source, scala]
--
def fetchLastOffset:() Option[String] // from DB
--

[source, scala]
--
eventsFrom(fetchLastOffset()).foreach { eventWithOffset =>
  eventWithOffset match
    case (UserEvent.UsernameChanged(id, name), offset) =>
      val user = fetchUser(id) // get state from DB
      val newUser = user.copy(name)
      saveUser(newUser) // save updated state in DB
      saveOffset(offset) // save offset in DB
} // return Unit (void)
--

[NOTE.speaker]
--
This is the typical projection that you'll find on production.
--

== Pitfalls with processing events

=== Commiting offset upfront

=== !

[source, scala]
--
eventsFrom(fetchLastOffset()).foreach {
  case (UserEvent.UsernameChanged(id, name), offset) =>
    val user = fetchUser(id)
    val newUser = user.copy(name)
    saveUser(newUser)
    saveOffset(offset)
}
--

[NOTE.speaker]
--
I inlined pattern matching for convenience.

This isn't what some implementations will give you.
--

[transition="slide-in fade-out"]
=== !

[source, scala]
--
// 1. fetches the last offset
// 2. starts streaming events since offset
// 3. commits offset before returning event
def newEvents(): Stream[UserEvent]
--

[source, scala]
--
newEvents().foreach {
  // no need to pass offset here
  case UserEvent.UsernameChanged(id, name)) =>
    val user = fetchUser(id)
    val newUser = user.copy(name)
    saveUser(newUser)
}
--

[NOTE.speaker]
--
This is what many Akka Streams integrations (Alpakka) do by default.
--

[transition="fade"]
=== !

[source, scala]
--
// 1. fetches the last offset
// 2. starts streaming events since offset
// 3. commits offset before returning event
def newEvents(): Stream[UserEvent]
--

[source, scala]
--
newEvents().foreach {
  case UserEvent.UsernameChanged(id, name)) =>
    // let's say process the crashed when we were here
    val user = fetchUser(id)
    val newUser = user.copy(name)
    saveUser(newUser)
}
--

[NOTE.speaker]
--
Event ends up not being projected!
--

[transition="fade-in slide-out"]
=== !

[source, scala]
--
// 1. fetches the last offset
// 2. starts streaming events since offset
// 3. DOES NOT commits offset before returning event
def newEvents(): Stream[(UserEvent, Offset)]
--

[source, scala]
--
newEvents().map {
  case (UserEvent.UsernameChanged(id, name)), offset) =>
    val user = fetchUser(id)
    val newUser = user.copy(name)
    saveUser(newUser)
    offset
}.foreach(offset => saveOffset(offset))
--

[NOTE.speaker]
--
Saving offset yourself prevents the situation when event get lost.

But what if app crash and we did something that shouldn't be repeated?
--

=== Lack of idempotency

=== !

example for lack of idempotency

=== Shared global state

=== !

Global state (e.g. distinct name)

== Pitfalls with creating events

== Pitfalls with events lifecycle

== Summary

=== !

Ask yourself what will happen when:

[%step]
* your process will crash/get killed
* someone will send the same event/command twice
* you will need to rerun projection from some point in past (maybe even from the start)
* the format of your events will need to be changed

[%step]
Would you arrive at the same state in the end?

[NOTE.speaker]
--
Is the final state the deterministic outcome of our history?
--

=== !

Also ask yourself:

[%step]
* why you used Event Sourcing in the first place
* is the way you use it helping achieving you your goal
* what is the worst outcome of doing ES "wrong"

[NOTE.speaker]
--
If the worst that can happen is not that bad, then there is hardly any reason to be "dogmatic".
--

== Thank you!

